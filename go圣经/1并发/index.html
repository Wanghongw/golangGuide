<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>01 并发 - Golang服务端入门与进阶指南</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../../css/theme.css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "01 \u5e76\u53d1";
    var mkdocs_page_input_path = "go\u5723\u7ecf/1\u5e76\u53d1.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> Golang服务端入门与进阶指南</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <p class="caption"><span class="caption-text">个人实践总结</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%9F%BA%E7%A1%80/%E4%B8%AA%E4%BA%BA%E5%AE%9E%E8%B7%B5/">01 个人博客总结</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Golang基础总结</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%9F%BA%E7%A1%80/1/">01 基础知识到循环</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%9F%BA%E7%A1%80/2/">02 容器类型</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%9F%BA%E7%A1%80/3/">03 函数闭包指针</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%9F%BA%E7%A1%80/4/">04 值/引用类型与异常处理</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%9F%BA%E7%A1%80/5/">05 结构体接口与反射</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%9F%BA%E7%A1%80/6/">06 各种内置模块的使用</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%9F%BA%E7%A1%80/7/">07 网编并发</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">《Go语言圣经》笔记</span></p>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">01 并发</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#81-goroutines">8.1 Goroutines</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#82-clock">8.2 示例:并发的clock服务❓</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#83-echo">8.3 示例:并发的echo服务❓</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#84-channels">8.4✨ Channels</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#channel">创建channel</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#channel_1">channel的类型及比较</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#channel_2">channel的发送与接收</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#channel_3">关闭channel</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#bufferedunbuffered-channel">buffered与unbuffered channel</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#841-channel">8.4.1✨ 不带缓存的channel</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_2">重要特性</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#happens-before">happens before</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#channel_4">同步channel的示例</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#842-channelpipeline">8.4.2✨ 串联的channel(pipeline)</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#843-channel">8.4.3✨ 单方向的channel</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#844-channel">8.4.4✨ 带缓存的channel</a>
    </li>
    </ul>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">Golang服务端入门与进阶指南</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>《Go语言圣经》笔记 &raquo;</li>
        
      
    
    <li>01 并发</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h2 id="_1"></h2>
<h3 id="81-goroutines">8.1 Goroutines</h3>
<p>在Go语言中，每一个并发的执行单元叫作一个goroutine。设想这里的一个程序有两个函数，一个函数做计算，另一个输出结果，假设两个函数没有相互之间的调用关系。一个线性的程序会先调用其中的一个函数，然后再调用另一个。如果程序中包含多个goroutine，对两个函数的调用则可能发生在同一时刻。马上就会看到这样的一个程序。</p>
<p>如果你使用过操作系统或者其它语言提供的线程，那么你可以简单地把goroutine类比作一个线程，这样你就可以写出一些正确的程序了。goroutine和线程的本质区别会在9.8节中讲。</p>
<p><strong>当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建。在语法上，go语句是一个普通的函数或方法调用前加上关键字go。</strong></p>
<p><strong>go语句会使其语句中的函数在一个新创建的goroutine中运行。而go语句本身会迅速地完成。</strong></p>
<pre><code class="language-c++">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main(){
    // 与main goroutine 同时执行，主goroutine结束它也跟着结束了
    go spinner(time.Millisecond * 100)
    const n = 45
    fibN := fib(n)
    fmt.Printf(&quot;fib(%d): %d\n&quot;,n , fibN)

}

// 打印等待的图标
func spinner(delay time.Duration){
    for {
        for _, r := range `-\|/`{
            fmt.Printf(&quot;\r%c&quot;, r)
            time.Sleep(delay)
        }
    }
}

// 计算斐波那契数列第n个值
func fib(x int) int{
    if x &lt; 2{
        return x
    }
    return fib(x-1) + fib(x-2)
}
</code></pre>
<p><strong>主函数返回时，所有的goroutine都会被直接打断，程序退出。</strong></p>
<p><strong>❗️除了从主函数退出或者直接终止程序之外，没有其它的编程方法能够让一个goroutine来打断另一个的执行。</strong></p>
<p><strong>❗️但是之后可以看到一种方式来实现这个目的，通过goroutine之间的通信来让一个goroutine请求其它的goroutine，并让被请求的goroutine自行结束执行。</strong></p>
<h3 id="82-clock">8.2 示例:并发的clock服务❓</h3>
<p>...</p>
<h3 id="83-echo">8.3 示例:并发的echo服务❓</h3>
<p>...</p>
<h3 id="84-channels">8.4✨ Channels</h3>
<p><strong>如果说goroutine是Go语言程序的并发体的话，那么channels则是它们之间的通信机制。</strong></p>
<p><strong>一个channel是一个通信机制，它可以让一个goroutine通过它给另一个goroutine发送值信息。</strong></p>
<p><strong>每个channel都有一个特殊的类型，也就是channels可发送数据的类型。</strong></p>
<p><strong>一个可以发送string类型数据的channel一般写为chan string。</strong></p>
<h4 id="channel">创建channel</h4>
<pre><code class="language-c++">ch := make(chan string)
</code></pre>
<h4 id="channel_1">channel的类型及比较</h4>
<p><strong>和map类似，channel也对应一个make创建的底层数据结构的引用。</strong></p>
<p><strong>❗️当我们复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用，因此调用者和被调用者将引用同一个channel对象。</strong></p>
<p><strong>和其它的引用类型一样，channel的零值也是nil。</strong></p>
<p><strong>两个相同类型的channel可以使用==运算符比较。如果两个channel引用的是相同的对象，那么比较的结果为真。一个channel也可以和nil进行比较。</strong></p>
<h4 id="channel_2">channel的发送与接收</h4>
<p><strong>一个channel有发送和接受两个主要操作，都是通信行为。</strong></p>
<p><strong>一个发送语句将一个值从一个goroutine通过channel发送到另一个执行接收操作的goroutine。</strong></p>
<p><strong>发送和接收两个操作都使用<code>&lt;-</code>运算符。</strong></p>
<p><strong>在发送语句中，<code>&lt;-</code>运算符分割channel和要发送的值。</strong></p>
<p><strong>在接收语句中，<code>&lt;-</code>运算符写在channel对象之前。</strong></p>
<p><strong>一个不使用接收结果的接收操作也是合法的。</strong></p>
<pre><code class="language-c++">ch &lt;- x  // a send statement
x = &lt;-ch // a receive expression in an assignment statement
&lt;-ch     // a receive statement; result is discarded(丢弃)
</code></pre>
<h4 id="channel_3">关闭channel</h4>
<p><strong>Channel还支持close操作，用于关闭channel，随后对基于该channel的任何<code>发送</code>操作都将导致panic异常。</strong></p>
<p><strong>对一个已经被close过的channel进行<code>接收</code>操作依然可以接受到之前已经成功发送的数据；</strong></p>
<p><strong>如果channel中已经没有数据的话将产生一个<code>零值</code>的数据。</strong></p>
<p>使用内置的close函数就可以关闭一个channel：</p>
<pre><code class="language-c++">close(ch)
</code></pre>
<h4 id="bufferedunbuffered-channel">buffered与unbuffered channel</h4>
<p>以最简单方式调用make函数创建的是一个无缓存的channel，但是我们也可以指定第二个整型参数，对应channel的容量。如果channel的容量大于零，那么该channel就是带缓存的channel。</p>
<pre><code class="language-c++">ch = make(chan int)    // unbuffered channel
ch = make(chan int, 0) // unbuffered channel
ch = make(chan int, 3) // buffered channel with capacity 3
</code></pre>
<h3 id="841-channel">8.4.1✨ 不带缓存的channel</h3>
<h4 id="_2">重要特性</h4>
<p><strong>❗️一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。</strong></p>
<p><strong>基于无缓存Channels的发送和接收操作将导致两个goroutine做一次<code>同步</code>操作。因为这个原因，无缓存Channels有时候也被称为<code>同步Channels</code>。</strong></p>
<p><strong>当通过一个无缓存Channels发送数据时，接收者收到数据发生在再次唤醒发送者goroutine之前（译注：<code>happens before</code>，这是Go语言并发内存模型的一个关键术语！）。</strong></p>
<h4 id="happens-before">happens before</h4>
<p><strong>在讨论并发编程时，当我们说x事件在y事件之前发生（<em>happens before</em>），我们并不是说x事件在时间上比y时间更早；我们要表达的意思是要保证<code>在此之前的事件都已经完成了</code>，例如在此之前的更新某些变量的操作已经完成，你可以放心依赖这些已完成的事件了。</strong></p>
<p><strong>当我们说x事件既不是在y事件之前发生也不是在y事件之后发生，我们就说x事件和y事件是并发的。这并不是意味着x事件和y事件就一定是同时发生的，我们只是不能确定这两个事件发生的先后顺序。</strong></p>
<p><strong>在下一章中我们将看到，当两个goroutine并发访问了相同的变量时，我们有必要保证某些事件的执行顺序，以避免出现某些并发问题。</strong></p>
<h4 id="channel_4">同步channel的示例</h4>
<p>在8.3节的客户端程序，它在<code>主goroutine</code>中（译注：就是<code>执行main函数的goroutine</code>）将标准输入复制到server，因此当客户端程序关闭标准输入时，后台goroutine可能依然在工作。我们需要让主goroutine等待后台goroutine完成工作后再退出，我们使用了一个channel来同步两个goroutine：</p>
<pre><code class="language-c++">

</code></pre>
<h3 id="842-channelpipeline">8.4.2✨ 串联的channel(pipeline)</h3>
<h3 id="843-channel">8.4.3✨ 单方向的channel</h3>
<h3 id="844-channel">8.4.4✨ 带缓存的channel</h3>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="../../%E5%9F%BA%E7%A1%80/7/" class="btn btn-neutral" title="07 网编并发"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../../%E5%9F%BA%E7%A1%80/7/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
