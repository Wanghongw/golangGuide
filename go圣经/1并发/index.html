<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>01 goroutine与channels - Golang服务端入门与进阶指南</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../../css/theme.css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "01 goroutine\u4e0echannels";
    var mkdocs_page_input_path = "go\u5723\u7ecf/1\u5e76\u53d1.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> Golang服务端入门与进阶指南</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <p class="caption"><span class="caption-text">个人实践总结</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%9F%BA%E7%A1%80/%E4%B8%AA%E4%BA%BA%E5%AE%9E%E8%B7%B5/">01 个人博客总结</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Golang基础总结</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%9F%BA%E7%A1%80/1/">01 基础知识到循环</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%9F%BA%E7%A1%80/2/">02 容器类型</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%9F%BA%E7%A1%80/3/">03 函数闭包指针</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%9F%BA%E7%A1%80/4/">04 值/引用类型与异常处理</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%9F%BA%E7%A1%80/5/">05 结构体接口与反射</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%9F%BA%E7%A1%80/6/">06 各种内置模块的使用</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%9F%BA%E7%A1%80/7/">07 网编并发</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">《Go语言圣经》笔记</span></p>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">01 goroutine与channels</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#81-goroutines">8.1 Goroutines</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#82-clock">8.2 示例:并发的clock服务❓</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#83-echo">8.3 示例:并发的echo服务❓</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#84-channels">8.4✨ Channels</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#channel">创建channel</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#channel_1">channel的类型及比较</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#channel_2">channel的发送与接收</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#channel_3">关闭channel</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#bufferedunbuffered-channel">buffered与unbuffered channel</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#841-channel">8.4.1✨ 不带缓存的channel</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_2">重要特性</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#happens-before">happens before</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#channel_4">同步channel的示例</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#842-channelpipeline">8.4.2✨ 串联的channel(pipeline)</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_3">接收操作的变体</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#range">❗️使用range接收</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_4">重要概念</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#843-channel">8.4.3✨ 单方向的channel</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#844-channel">8.4.4✨ 带缓存的channel</a>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F--%E5%9F%BA%E7%A1%80/">基础</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">Golang服务端入门与进阶指南</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>《Go语言圣经》笔记 &raquo;</li>
        
      
    
    <li>01 goroutine与channels</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h2 id="_1"></h2>
<h3 id="81-goroutines">8.1 Goroutines</h3>
<p>在Go语言中，每一个并发的执行单元叫作一个goroutine。设想这里的一个程序有两个函数，一个函数做计算，另一个输出结果，假设两个函数没有相互之间的调用关系。一个线性的程序会先调用其中的一个函数，然后再调用另一个。如果程序中包含多个goroutine，对两个函数的调用则可能发生在同一时刻。马上就会看到这样的一个程序。</p>
<p>如果你使用过操作系统或者其它语言提供的线程，那么你可以简单地把goroutine类比作一个线程，这样你就可以写出一些正确的程序了。goroutine和线程的本质区别会在9.8节中讲。</p>
<p><strong>当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建。在语法上，go语句是一个普通的函数或方法调用前加上关键字go。</strong></p>
<p><strong>go语句会使其语句中的函数在一个新创建的goroutine中运行。而go语句本身会迅速地完成。</strong></p>
<pre><code class="language-c++">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main(){
    // 与main goroutine 同时执行，主goroutine结束它也跟着结束了
    go spinner(time.Millisecond * 100)
    const n = 45
    fibN := fib(n)
    fmt.Printf(&quot;fib(%d): %d\n&quot;,n , fibN)

}

// 打印等待的图标
func spinner(delay time.Duration){
    for {
        for _, r := range `-\|/`{
            fmt.Printf(&quot;\r%c&quot;, r)
            time.Sleep(delay)
        }
    }
}

// 计算斐波那契数列第n个值
func fib(x int) int{
    if x &lt; 2{
        return x
    }
    return fib(x-1) + fib(x-2)
}
</code></pre>
<p><strong>主函数返回时，所有的goroutine都会被直接打断，程序退出。</strong></p>
<p><strong>❗️除了从主函数退出或者直接终止程序之外，没有其它的编程方法能够让一个goroutine来打断另一个的执行。</strong></p>
<p><strong>❗️但是之后可以看到一种方式来实现这个目的，通过goroutine之间的通信来让一个goroutine请求其它的goroutine，并让被请求的goroutine自行结束执行。</strong></p>
<h3 id="82-clock">8.2 示例:并发的clock服务❓</h3>
<p>...</p>
<h3 id="83-echo">8.3 示例:并发的echo服务❓</h3>
<p>...</p>
<h3 id="84-channels">8.4✨ Channels</h3>
<p><strong>如果说goroutine是Go语言程序的并发体的话，那么channels则是它们之间的通信机制。</strong></p>
<p><strong>一个channel是一个通信机制，它可以让一个goroutine通过它给另一个goroutine发送值信息。</strong></p>
<p><strong>每个channel都有一个特殊的类型，也就是channels可发送数据的类型。</strong></p>
<p><strong>一个可以发送string类型数据的channel一般写为chan string。</strong></p>
<h4 id="channel">创建channel</h4>
<pre><code class="language-c++">ch := make(chan string)
</code></pre>
<h4 id="channel_1">channel的类型及比较</h4>
<p><strong>和map类似，channel也对应一个make创建的底层数据结构的引用。</strong></p>
<p><strong>❗️当我们复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用，因此调用者和被调用者将引用同一个channel对象。</strong></p>
<p><strong>和其它的引用类型一样，channel的零值也是nil。</strong></p>
<p><strong>两个相同类型的channel可以使用==运算符比较。如果两个channel引用的是相同的对象，那么比较的结果为真。一个channel也可以和nil进行比较。</strong></p>
<h4 id="channel_2">channel的发送与接收</h4>
<p><strong>一个channel有发送和接受两个主要操作，都是通信行为。</strong></p>
<p><strong>一个发送语句将一个值从一个goroutine通过channel发送到另一个执行接收操作的goroutine。</strong></p>
<p><strong>发送和接收两个操作都使用<code>&lt;-</code>运算符。</strong></p>
<p><strong>在发送语句中，<code>&lt;-</code>运算符分割channel和要发送的值。</strong></p>
<p><strong>在接收语句中，<code>&lt;-</code>运算符写在channel对象之前。</strong></p>
<p><strong>一个不使用接收结果的接收操作也是合法的。</strong></p>
<pre><code class="language-c++">ch &lt;- x  // a send statement
x = &lt;-ch // a receive expression in an assignment statement
&lt;-ch     // a receive statement; result is discarded(丢弃)
</code></pre>
<h4 id="channel_3">关闭channel</h4>
<p><strong>Channel还支持close操作，用于关闭channel，随后对基于该channel的任何<code>发送</code>操作都将导致panic异常。</strong></p>
<p><strong>对一个已经被close过的channel进行<code>接收</code>操作依然可以接受到之前已经成功发送的数据；</strong></p>
<p><strong>如果channel中已经没有数据的话将产生一个<code>零值</code>的数据。</strong></p>
<p>使用内置的close函数就可以关闭一个channel：</p>
<pre><code class="language-c++">close(ch)
</code></pre>
<h4 id="bufferedunbuffered-channel">buffered与unbuffered channel</h4>
<p>以最简单方式调用make函数创建的是一个无缓存的channel，但是我们也可以指定第二个整型参数，对应channel的容量。如果channel的容量大于零，那么该channel就是带缓存的channel。</p>
<pre><code class="language-c++">ch := make(chan int)    // unbuffered channel
ch := make(chan int, 0) // unbuffered channel
ch := make(chan int, 3) // buffered channel with capacity 3
</code></pre>
<h3 id="841-channel">8.4.1✨ 不带缓存的channel</h3>
<h4 id="_2">重要特性</h4>
<p><strong>❗️一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。</strong></p>
<p><strong>基于无缓存Channels的发送和接收操作将导致两个goroutine做一次<code>同步</code>操作。因为这个原因，无缓存Channels有时候也被称为<code>同步Channels</code>。</strong></p>
<p><strong>当通过一个无缓存Channels发送数据时，接收者收到数据发生在再次唤醒发送者goroutine之前（译注：<code>happens before</code>，这是Go语言并发内存模型的一个关键术语！）。</strong></p>
<h4 id="happens-before">happens before</h4>
<p><strong>在讨论并发编程时，当我们说x事件在y事件之前发生（<em>happens before</em>），我们并不是说x事件在时间上比y时间更早；我们要表达的意思是要保证<code>在此之前的事件都已经完成了</code>，例如在此之前的更新某些变量的操作已经完成，你可以放心依赖这些已完成的事件了。</strong></p>
<p><strong>当我们说x事件既不是在y事件之前发生也不是在y事件之后发生，我们就说x事件和y事件是并发的。这并不是意味着x事件和y事件就一定是同时发生的，我们只是不能确定这两个事件发生的先后顺序。</strong></p>
<p><strong>在下一章中我们将看到，当两个goroutine并发访问了相同的变量时，我们有必要保证某些事件的执行顺序，以避免出现某些并发问题。</strong></p>
<h4 id="channel_4">同步channel的示例</h4>
<p>在8.3节的客户端程序，它在<code>主goroutine</code>中（译注：就是<code>执行main函数的goroutine</code>）将标准输入复制到server，因此当客户端程序关闭标准输入时，后台goroutine可能依然在工作。我们需要让主goroutine等待后台goroutine完成工作后再退出，我们使用了一个channel来同步两个goroutine：</p>
<pre><code class="language-c++">package main

import (
    &quot;log&quot;
)

func main() {
    // 定义一个无缓存的channel
    done := make(chan string)

    // 子goroutine
    go func(){
        log.Println(&quot;son goroutine has done...&quot;)
        // send
        done &lt;- &quot;fucking done!&quot; // signal the main goroutine
    }()
    // 下面的打印语句与子goroutine同时执行！
    log.Println(&quot;main goroutine1.....&quot;)

    &lt;- done // 等待后台子goroutine执行完才执行下面的打印语句！
    log.Println(&quot;main goroutine2.....&quot;)
}
</code></pre>
<p><strong>基于channels发送消息有两个重要方面。首先每个消息都有一个值，但是有时候通讯的<code>事实</code>和<code>发生的时刻</code>也同样重要。</strong></p>
<p><strong>当我们更希望强调通讯发生的时刻时，我们将它称为<code>消息事件</code>。</strong></p>
<p><strong>有些消息事件并不携带额外的信息，它仅仅是用作两个goroutine之间的同步，这时候我们可以用<code>struct{}</code>空结构体作为channels元素的类型，虽然也可以使用bool或int类型实现同样的功能，<code>done &lt;- 1</code>语句也比<code>done &lt;- struct{}{}</code>更短。</strong></p>
<h3 id="842-channelpipeline">8.4.2✨ 串联的channel(pipeline)</h3>
<p><strong>Channels也可以用于将多个goroutine连接在一起，一个Channel的输出作为下一个Channel的输入。这种串联的Channels就是所谓的管道（pipeline）。下面的程序用两个channels将三个goroutine串联起来：</strong></p>
<p><img alt="image-20210505081542512" src="../../imgs/image-20210505081542512.png" /></p>
<p>第一个goroutine是一个计数器，用于生成0、1、2、……形式的整数序列，然后通过channel将该整数序列发送给第二个goroutine；第二个goroutine是一个求平方的程序，对收到的每个整数求平方，然后将平方后的结果通过第二个channel发送给第三个goroutine；第三个goroutine是一个打印程序，打印收到的每个整数。为了保持例子清晰，我们有意选择了非常简单的函数，当然三个goroutine的计算很简单，在现实中确实没有必要为如此简单的运算构建三个goroutine：</p>
<pre><code class="language-c++">package main

import &quot;fmt&quot;

func main() {

    naturals := make(chan int)
    squares := make(chan int)

    // Counter
    go func(){
        // 无限往里面加
        for x := 0; ; x++{
            naturals &lt;- x
        }
    }()

    // Squarer
    go func(){
        for {
            x := &lt;- naturals
            squares &lt;- x * x
        }
    }()

    // Printer
    for{
        y := &lt;- squares
        // 限制...
        if y &gt; 10000{
            // 关闭
            close(naturals)
            close(squares)
            fmt.Println(y)
            return
        }
        fmt.Println(y)
    }
}
</code></pre>
<p><strong>❗️当一个channel被关闭后，再向该channel发送数据将导致panic异常。</strong></p>
<p><strong>❗️当一个被关闭的channel中已经发送的数据都被成功接收后，后续的接收操作将不再阻塞，它们会立即返回一个零值。</strong></p>
<p><strong>关闭上面例子中的naturals变量对应的channel并不能终止循环，它依然会收到一个永无休止的零值序列，然后将它们发送给打印者goroutine。</strong></p>
<h4 id="_3">接收操作的变体</h4>
<p><strong>没有办法直接测试一个channel是否被关闭，但是接收操作有一个变体形式：它多接收一个结果，多接收的第二个结果是一个布尔值ok，ture表示成功从channels接收到值，false表示channels已经被关闭并且里面没有值可接收。</strong></p>
<p><strong>使用这个特性，我们可以修改squarer函数中的循环代码，当naturals对应的channel被关闭并没有值可接收时跳出循环，并且也关闭squares对应的channel.</strong></p>
<pre><code class="language-c++">    // Squarer
    go func(){
        for {
            x, ok := &lt;- naturals
            if !ok{
                break // channel was closed and drained
            }
            squares &lt;- x * x
        }
        close(squares)
    }()
</code></pre>
<h4 id="range">❗️使用range接收</h4>
<p><strong>因为上面的语法是笨拙的，而且这种处理模式很常见，因此Go语言的range循环可直接在channels上面迭代。</strong></p>
<p><strong>使用range循环是上面处理模式的简洁语法，它<code>依次从channel接收数据</code>，<code>当channel被关闭并且没有值可接收时跳出循环</code>。</strong></p>
<pre><code class="language-c++">package main

import &quot;fmt&quot;

func main() {

    naturals := make(chan int)
    squares := make(chan int)

    // Counter
    go func(){
        // 100个
        for x := 0; x&lt;100; x++{
            naturals &lt;- x
        }
        // close
        close(naturals)
    }()

    // Squarer
    go func(){
        // for ... range 的方式
        for x := range naturals{
            squares &lt;- x * x
        }
        // close
        close(squares)
    }()

    // Printer 主goroutine中
    for x := range squares{
        fmt.Println(&quot;x: &quot;, x)
    }
}
</code></pre>
<h4 id="_4">重要概念</h4>
<p><strong>❗️其实你并不需要关闭每一个channel。只有当需要告诉接收者goroutine，所有的数据已经全部发送时才需要关闭channel。</strong></p>
<p><strong>❗️不管一个channel是否被关闭，当它没有被引用时将会被Go语言的垃圾自动回收器回收。</strong></p>
<p><strong>不要将关闭一个打开文件的操作和关闭一个channel操作混淆。对于每个打开的文件，都需要在不使用的时候调用对应的Close方法来关闭文件。</strong></p>
<p><strong>试图重复关闭一个channel将导致panic异常，试图关闭一个nil值的channel也将导致panic异常。关闭一个channels还会触发一个广播机制。</strong></p>
<h3 id="843-channel">8.4.3✨ 单方向的channel</h3>
<h3 id="844-channel">8.4.4✨ 带缓存的channel</h3>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F--%E5%9F%BA%E7%A1%80/" class="btn btn-neutral float-right" title="基础">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../../%E5%9F%BA%E7%A1%80/7/" class="btn btn-neutral" title="07 网编并发"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../../%E5%9F%BA%E7%A1%80/7/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F--%E5%9F%BA%E7%A1%80/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
