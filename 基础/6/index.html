<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>06 各种内置模块的使用 - Golang服务端入门与进阶指南</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../../css/theme.css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "06 \u5404\u79cd\u5185\u7f6e\u6a21\u5757\u7684\u4f7f\u7528";
    var mkdocs_page_input_path = "\u57fa\u7840/6.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> Golang服务端入门与进阶指南</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <p class="caption"><span class="caption-text">个人实践总结</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../%E4%B8%AA%E4%BA%BA%E5%AE%9E%E8%B7%B5/">01 个人博客总结</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Golang基础总结</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="../1/">01 基础知识到循环</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../2/">02 容器类型</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../3/">03 函数闭包指针</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../4/">04 值/引用类型与异常处理</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../5/">05 结构体接口与反射</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">06 各种内置模块的使用</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#0new">0、new函数</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#1">1 字符串的操作</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#11">1.1 字符串的遍历 ***</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#12-strings">1.2 strings包的字符串处理函数</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_2">检索字符串</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_3">分割字符串</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_4">大小写转换</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_5">修剪字符串</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_6">比较字符串</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#13">1.3 字符串其他操作</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#0">0）修改字符串</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#1_1">1) 统计字符串长度(按字节)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2">2) 字符串遍历，同时处理有中文的问题</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3">3) 字符串转整数</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#4">4) 整数转字符串</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#5">5)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#6">6) 查找子串是否在指定的字符串中</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#7">7) 统计一个字符串有几个指定的子串</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#8">8) 不区分大小写的比较</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#9">9) 其他整合</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#2strconv">2、strconv包常用函数</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#parse">Parse类函数</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#format">Format类函数</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#3_1">3、时间处理函数</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#30-time">3.0 time包常用函数</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#4-math">4、 math包常用函数</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#5_1">5、随机数</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_7">获取随机数的几种方式</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#6regexp">6、regexp正则表达式包</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#regexp">regexp包中核心函数及方法介绍</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#7-goio">7 Go语言文件I/O操作</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#71">7.1 文件概述</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#72-fileinfo">7.2 FIleInfo接口</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_8">文件权限简单说明</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#73">7.3 文件路径</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#74">7.4 文件常规操作</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_9">创建目录</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_10">创建文件</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_11">打开和关闭文件</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_12">删除文件</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_13">读取文件</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_14">写入文件</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_15">复制文件</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#75-ioutil">7.5 ioutil包</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#76-bufio">7.6 bufio包</a>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../7/">07 网编并发</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">《Go语言圣经》笔记</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../go%E5%9C%A3%E7%BB%8F/1%E5%B9%B6%E5%8F%91/">01 goroutine与channels</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../go%E5%9C%A3%E7%BB%8F/Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F--%E5%9F%BA%E7%A1%80/">基础</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">Golang服务端入门与进阶指南</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>Golang基础总结 &raquo;</li>
        
      
    
    <li>06 各种内置模块的使用</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h2 id="_1"></h2>
<h3 id="0new">0、new函数</h3>
<p>new：用来分配内存，主要用来分配值类型：int、float32、struct...返回的是一个指向这个数据类型的指针。</p>
<p><img alt="image-20201118194804441" src="../../imgs/image-20201118194804441.png" /></p>
<h3 id="1">1 字符串的操作</h3>
<h4 id="11">1.1 字符串的遍历 ***</h4>
<pre><code class="language-c++">package main

import (
    &quot;fmt&quot;
    &quot;unicode/utf8&quot;
)

func main() {
    s1 := &quot;火影whw&quot;
    // 1、for ... range 遍历字符串
    for i, ch := range s1{
        fmt.Printf(&quot;%d:%c &quot;,i, ch)
    }
    // 注意：一个中文字符占3个字节（unitcode编码规范）
    // 0:火 3:影 6:w 7:h 8:w

    // 2、遍历所有字节
    for i, ch := range []byte(s1){
        fmt.Printf(&quot;%d:%x &quot;,i, ch)
    }
    // 0:e7 1:81 2:ab 3:e5 4:bd 5:b1 6:77 7:68 8:77

    // 3、遍历所有字符（包含中文）***
    for i, ch := range []rune(s1){
        fmt.Printf(&quot;%d:%c &quot;,i, ch)
    }
    // 0:火 1:影 2:w 3:h 4:w

    // 4、带中文的字符串长度 ***
    fmt.Println(&quot;字符串长度&gt;&gt;&gt; &quot;,utf8.RuneCountInString(s1))
    //字符串长度&gt;&gt;&gt;  5
}
</code></pre>
<p>可以看出，<strong>如果字符串涉及中文，遍历字符推荐使用rune。因为一个byte存不下一个汉语文字的unicode值。</strong></p>
<h4 id="12-strings">1.2 strings包的字符串处理函数</h4>
<h4 id="_2">检索字符串</h4>
<p><img alt="image-20201117171010116" src="../../imgs/image-20201117171010116.png" /></p>
<h4 id="_3">分割字符串</h4>
<p><img alt="image-20201201172124519" src="../../imgs/image-20201201172124519.png" /></p>
<pre><code class="language-c++">package main

import (
    &quot;fmt&quot;
    &quot;strings&quot;
    &quot;unicode&quot;
)

func main() {
    // 1、将字符串以空白字符分割，并返回一个切片
    ret := strings.Fields(&quot;   abc 123 ABC h s  XXYY&quot;)
    fmt.Println(ret) // [abc 123 ABC h s XXYY]

    // 2、将字符串以满足 f(r)==true 的字符分割，返回一个切片
    f := func(c rune) bool{
        // 既不是字母也不是数字 —— 特殊字符或者空格等。。。
        return !unicode.IsLetter(c) &amp;&amp; !unicode.IsNumber(c)
    }
    ret = strings.FieldsFunc(&quot;abd#123*ghs@whw   sdf&quot;,f)
    fmt.Println(ret) // [abd 123 ghs whw sdf]

    // 3、将字符串以sep作为分隔符进行分割，分割后字符去掉sep
    ret1 := strings.Split(&quot;a,b,c&quot;,&quot;,&quot;)
    fmt.Println(ret1)//[a b c]
    // 全部分割
    ret2 := strings.Split(&quot;xyz sd 123&quot;,&quot;&quot;)
    fmt.Println(ret2)//[x y z   s d   1 2 3]
    // 没有的话列表中只有一个元素
    ret3 := strings.Split(&quot;aa,,,b,,c&quot;,&quot;*&quot;)
    fmt.Println(ret3)//[aa,,,b,,c]

    // 4、将字符串以sep作为分割符进行分割，分割后字符最后附上sep，n决定返回的切片中元素的数量
    ret1 = strings.SplitN(&quot;a,b,c,d&quot;,&quot;,&quot;,2) // 如果n大于最多的熟练则返回切片后所有的数
    fmt.Println(ret1)//[a b,c,d]
    ret1 = strings.SplitN(&quot;a,b,c,d&quot;,&quot;,&quot;,1) // 如果n大于最多的熟练则返回切片后所有的数
    fmt.Println(ret1)//[a,b,c,d]

    // 5、将字符串以sep作为分隔符进行分割，分割后字符最后附上sep
    ret = strings.SplitAfter(&quot;a,b,c,d&quot;,&quot;,&quot;)
    fmt.Println(ret) // [a, b, c, d]  ———— 注意d后面本身没有逗号，所以转成切片后也没有逗号

    // 6、将字符串以sep作为分隔符进行分割，分割后字符最后附上sep，n决定返回的切片中元素的数量
    ret = strings.SplitAfterN(&quot;a,b,c,d&quot;,&quot;,&quot;,2)
    fmt.Println(ret)//[a, b,c,d]
}
</code></pre>
<h4 id="_4">大小写转换</h4>
<p><img alt="image-20201201174545070" src="../../imgs/image-20201201174545070.png" /></p>
<pre><code class="language-c++">package main

import (
    &quot;fmt&quot;
    &quot;strings&quot;
)

func main() {
    // 1、将字符串每个单词首字母大写返回
    ret := strings.Title(&quot;my name is narutoOO! &quot;)
    fmt.Println(ret)//My Name Is NarutoOO!

    // 2、将字符串转换成大写返回
    ret = strings.ToTitle(&quot;lius fdaSD*&amp;&quot;)
    fmt.Println(ret)//LIUS FDASD*&amp;

    // 3、将字符串转换成小写返回
    ret = strings.ToLower(&quot;ASD sdf#sASED faASDS&quot;)
    fmt.Println(ret)//asd sdf#sased faasds

    // 4、将字符串转换成大写返回
    ret = strings.ToUpper(&quot;lius fdaSD*&amp;&quot;)
    fmt.Println(ret)//LIUS FDASD*&amp;
}
</code></pre>
<h4 id="_5">修剪字符串</h4>
<p><img alt="image-20201201175116143" src="../../imgs/image-20201201175116143.png" /></p>
<pre><code class="language-c++">package main

import (
    &quot;fmt&quot;
    &quot;strings&quot;
    &quot;unicode&quot;
)

func main() {
    // 1、将字符串首尾包含在cutset中的任意一个字符去掉返回
    ret := strings.Trim(&quot;   see  wang   &quot;,&quot; &quot;)
    fmt.Println(ret)//see  wang

    // 2、将字符串首尾满足函数 f(r)==true 的字符去掉返回
    f := func(c rune) bool{
        // 既不是字符也不是数字
        return !unicode.IsLetter(c) &amp;&amp; !unicode.IsNumber(c)
    }
    ret = strings.TrimFunc(&quot;**dd%$sadf  123!2&amp;()&quot;,f)
    fmt.Println(ret)//dd%$sadf  123!2

    // 3、将字符串左边包含在cutset中的任意一个字符去掉返回
    ret = strings.TrimLeft(&quot;**&amp;!1231**&quot;,&quot;*&quot;)
    fmt.Println(ret)//&amp;!1231**

    // 4、将字符串左边满足函数 f(r)==true 的字符去掉返回
    ret = strings.TrimLeftFunc(&quot;**dd%$sadf  123!2&amp;()&quot;,f)
    fmt.Println(ret)//dd%$sadf  123!2&amp;()

    // 5、将字符串右边包含在cutset中的任意一个字符去掉返回
    ret = strings.TrimRight(&quot;**&amp;!1231**&quot;,&quot;*&quot;)
    fmt.Println(ret)//**&amp;!1231

    // 6、将字符串右边满足函数 f(r)==true 的字符去掉返回
    ret = strings.TrimRightFunc(&quot;**dd%$sadf  123!2&amp;()&quot;,f)
    fmt.Println(ret)//**dd%$sadf  123!2
}
</code></pre>
<h4 id="_6">比较字符串</h4>
<p><img alt="image-20201201181214679" src="../../imgs/image-20201201181214679.png" /></p>
<pre><code class="language-c++">package main

import (
    &quot;fmt&quot;
    &quot;strings&quot;
)

func main() {
    // 1、按照字典顺序比较2个字符串的大小
    fmt.Println(strings.Compare(&quot;abc&quot;,&quot;acd&quot;)) // -1
    fmt.Println(&quot;abc&quot; &lt; &quot;acd&quot;) // true

    // 2、判断两个 UTF-8字符串是否相等，忽略大小写
    fmt.Println(strings.EqualFold(&quot;Go&quot;,&quot;go&quot;))// true

    // 3、将字符串重复count次返回
    ret := &quot;g&quot; + strings.Repeat(&quot;had&quot;,3) + &quot;le&quot;
    fmt.Println(ret)//ghadhadhadle

    // 4、替换字符串s中old字符为new字符并返回， n&lt;0 时替换所有old字符
    ret1 := strings.Replace(&quot;王老大 王老二 王老三&quot;,&quot;王&quot;,&quot;张&quot;,2)
    fmt.Println(ret1)//张老大 张老二 王老三
    ret2 := strings.Replace(&quot;王老大 王老二 王老三&quot;,&quot;王&quot;,&quot;张&quot;,-1)
    fmt.Println(ret2)//张老大 张老二 张老三

    // 5、将a中所有字符连接成一个字符串，使用字符串sep作为分割符 ————— Join
    s := []string{&quot;abc&quot;,&quot;ABC&quot;,&quot;123&quot;}
    ret1 = strings.Join(s,&quot;,&quot;)
    fmt.Println(ret1)//abc,ABC,123
    ret2 = strings.Join(s,&quot;&quot;)
    fmt.Println(ret2)//abcABC123
}
</code></pre>
<h3 id="13">1.3 字符串其他操作</h3>
<h4 id="0">0）修改字符串</h4>
<p>如果想修改字符串，可以先将 string -&gt; []byte / 或者 []rune-&gt;修改-&gt;重写转成string。</p>
<p><img alt="image-20201118202800045" src="../../imgs/image-20201118202800045.png" /></p>
<h4 id="1_1">1) 统计字符串长度(按字节)</h4>
<p><strong>len函数</strong></p>
<pre><code class="language-c++">str := &quot;火影whw&quot;
fmt.Println(len(str)) // 9   注意一个中文字符占3个unitcode位
</code></pre>
<h4 id="2">2) 字符串遍历，同时处理有中文的问题</h4>
<p><strong>r := []rune(str)</strong></p>
<pre><code class="language-c++">str := &quot;火影whw&quot;
newStr := []rune(str)
for i,val := range newStr{
  fmt.Printf(&quot;%d:%c &quot;,i,val)
}
// 0:火 1:影 2:w 3:h 4:w
</code></pre>
<h4 id="3">3) 字符串转整数</h4>
<pre><code class="language-c++">n, err := strconv.Atoi(&quot;123&quot;)
if err != nil{
  fmt.Println(&quot;转换错误&quot;,err)
}else{
  fmt.Printf(&quot;result&gt;&gt;&gt; %v, %T \n&quot;,n, n) //123, int 
}
</code></pre>
<h4 id="4">4) 整数转字符串</h4>
<pre><code class="language-c++">str := strconv.Itoa(123)
fmt.Printf(&quot;str&gt;&gt;&gt; %v, %T \n&quot;,str, str) // 123, string 
</code></pre>
<h4 id="5">5)</h4>
<p><img alt="image-20201117200439210" src="../../imgs/image-20201117200439210.png" /></p>
<h4 id="6">6) 查找子串是否在指定的字符串中</h4>
<pre><code class="language-c++">b := strings.Contains(&quot;wanghw&quot;,&quot;ang&quot;)
    fmt.Println(b)// true
</code></pre>
<h4 id="7">7) 统计一个字符串有几个指定的子串</h4>
<pre><code class="language-c++">strings.Count(&quot;Chinese&quot;,&quot;c&quot;)
</code></pre>
<h4 id="8">8) 不区分大小写的比较</h4>
<pre><code class="language-c++">result := strings.EqualFold(&quot;whw&quot;,&quot;Whw&quot;)
fmt.Println(result)// true
</code></pre>
<h4 id="9">9) 其他整合</h4>
<pre><code class="language-c++">// 返回子串第一次出现的index值，没有就返回-1
    index := strings.Index(&quot;wanghw&quot;,&quot;w&quot;)
    fmt.Println(index)// 0

    // 返回子串在字符串最后一次出现的index，没有返回-1
    index = strings.LastIndex(&quot;wanghw&quot;,&quot;w&quot;)
    fmt.Println(index)// 5

    // 将指定的子串替换成另外一个子串，-1表示全部替换，可以设置想替换几个
    str := &quot;go go hello&quot;
    str1 := strings.Replace(str,&quot;go&quot;,&quot;hi&quot;,1)
    fmt.Println(str1) // hi go hello

    // 按照某个字符串分割，返回一个字符数组
    strArr := strings.Split(&quot;hello;hi;whw&quot;,&quot;;&quot;)
    for _, val := range strArr{
        fmt.Printf(&quot;%s\t&quot;,val)//hello   hi      whw
    }

    // 大小写转换 全转成小写
    str = strings.ToLower(&quot;WansHW&quot;)
    fmt.Println(str)//wanshw

    // 大小写转换 全转成大写
    str = strings.ToUpper(&quot;shaSAl&quot;)
    fmt.Println(str)//SHASAL

    // 将字符串左右两边的空格都去掉
    str = &quot;   asdf sdf jjj whw     &quot;
    str1 = strings.TrimSpace(str)
    fmt.Println(str1) //asdf sdf jjj whw

    // 去掉左右两边指定的字符
    str = &quot;!hello#!&quot;
    str1 = strings.Trim(str,&quot;!&quot;)
    fmt.Println(str1) //hello#

    // 去掉左边指定的字符：strings.TrimLeft(...)
    // 去掉右边指定的字符：strings.TrimRight(...)

    // 判断是否是以指定的字符串开头
    b := strings.HasPrefix(&quot;wanghyw&quot;,&quot;wa&quot;)
    fmt.Println(b) // true

    // 判断是否以指定字符串结束
    b = strings.HasSuffix(&quot;wanghhh,&quot;,&quot;,&quot;)
    fmt.Println(b) // true
</code></pre>
<h3 id="2strconv">2、strconv包常用函数</h3>
<p><strong>strconv包实现了字符串与其他基本数据类型之间的类型转换。</strong></p>
<h4 id="parse">Parse类函数</h4>
<p>Parse 类函数主要的功能是将字符串转换为其他类型，常用的 Parse 类函数如表：</p>
<p><img alt="image-20201201182709765" src="../../imgs/image-20201201182709765.png" /></p>
<pre><code class="language-c++">package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
)

func main() {
    // string -&gt; int
    _int, _ := strconv.Atoi(&quot;97&quot;)
    fmt.Println(_int, _int == int(97))

    // string -&gt; int64
    _int64, _ := strconv.ParseInt(&quot;97&quot;, 10, 64)
    fmt.Println(_int64, _int64 == int64(97))

  // https://stackoverflow.com/questions/30299649/parse-string-to-specific-type-of-int-int8-int16-int32-int64
    // string -&gt; int32，注意 parseInt 始终返回的是 int64，所以还是需要 int32(n) 强转一下
    _int32, _ := strconv.ParseInt(&quot;97&quot;, 10, 32)
    fmt.Println(_int32, int32(_int32) == int32(97))

    // string -&gt; float32/float64  https://yourbasic.org/golang/convert-string-to-float/
    f := &quot;3.14159265&quot;
    if s, err := strconv.ParseFloat(f, 32); err == nil {
        fmt.Println(s) // 3.1415927410125732
    }
    if s, err := strconv.ParseFloat(f, 64); err == nil {
        fmt.Println(s) // 3.14159265
    }
}
</code></pre>
<h4 id="format">Format类函数</h4>
<p><strong>Format类函数主要的功能是将其他类型格式化成字符串</strong></p>
<p><img alt="image-20201201193009841" src="../../imgs/image-20201201193009841.png" /></p>
<pre><code class="language-c++">// 推荐一个更加强大的转换库：https://github.com/spf13/cast
package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
)

func main() { // 测试 int 和 string(decimal) 互相转换的函数
    // https://yourbasic.org/golang/convert-int-to-string/
    // int -&gt; string
    sint := strconv.Itoa(97)
    fmt.Println(sint, sint == &quot;97&quot;)

    // byte -&gt; string
    bytea := byte(1)
    bint := strconv.Itoa(int(bytea))
    fmt.Println(bint)

    // int64 -&gt; string
    sint64 := strconv.FormatInt(int64(97), 10)
    fmt.Println(sint64, sint64 == &quot;97&quot;)

    // int64 -&gt; string (hex) ，十六进制
    sint64hex := strconv.FormatInt(int64(97), 16)
    fmt.Println(sint64hex, sint64hex == &quot;61&quot;)

    // int32 -&gt; string, https://stackoverflow.com/questions/39442167/convert-int32-to-string-in-golang
    fmt.Println(&quot;------- int32 -&gt; string ------&quot;)
    res1 := strconv.FormatInt(int64(23), 10) // fast
    fmt.Println(&quot;res1&gt;&gt;&gt; &quot;,res1)
    res2 := strconv.Itoa(int(23)) // fast
    fmt.Println(&quot;res2&gt;&gt;&gt; &quot;,res2)
    res3 := fmt.Sprint(23) // slow
    fmt.Println(&quot;re3s&gt;&gt;&gt; &quot;,res3)
    fmt.Println(&quot;-------------&quot;)
    // int -&gt; int64 ，不会丢失精度
    var n int = 97
    fmt.Println(int64(n) == int64(97))

    // float -&gt; string https://yourbasic.org/golang/convert-string-to-float/
    s := fmt.Sprintf(&quot;%f&quot;, 123.456)
    fmt.Println(&quot;s&gt;&gt;&gt; &quot;,s)
}
</code></pre>
<h3 id="3_1">3、时间处理函数</h3>
<h4 id="30-time">3.0 time包常用函数</h4>
<p><img alt="image-20201201193342673" src="../../imgs/image-20201201193342673.png" /></p>
<p><img alt="image-20201201193357476" src="../../imgs/image-20201201193357476.png" /></p>
<h3 id="4-math">4、 math包常用函数</h3>
<p><img alt="image-20201201193514873" src="../../imgs/image-20201201193514873.png" /></p>
<h3 id="5_1">5、随机数</h3>
<p>“math/rand”包实现了伪随机数生成器，能够生成<strong>整型</strong>和<strong>浮点型</strong>的随机数。</p>
<p>使用随机数生成器需要放入种子。可以使用Seed()函数生成一个不确定的种子放入随机数生成器，这样每次运行随机数生成器都会生成不同的序列。如果没有在随机数生成器中放入种子，则默认使用具有确定性状态的种子，此时可以理解为种子的值是一个常数1，即Seed(1)。</p>
<p><img alt="image-20201201193621239" src="../../imgs/image-20201201193621239.png" /></p>
<h4 id="_7">获取随机数的几种方式</h4>
<pre><code class="language-c++">println(rand.Int())
println(rand.Float64())
println(rand.Intn(12))// 获取 0-12随机数
</code></pre>
<p><strong>这样总是生成固定的随机数。默认情况下，随机数种子都是1。seed是一个64位整数。</strong></p>
<p>动态随机数种子生成随机资源，产生随机对象来获取随机数，具体方法如下所示:</p>
<pre><code class="language-c++">s1 := rand.NewSource(time.Now().UnixNano())
r1 := rand.New(s1)
randNum := r1.Intn(12) // 0-12随机数
fmt.Println(randNum)
</code></pre>
<p><strong>简写形式：动态变化随机数种子来获取随机数，具体方法如下所示:</strong></p>
<p>（1）获取整型 0～10随机数</p>
<pre><code class="language-c++">rand.Seed(time.Now().UnixNano())
rand.Intn(10)
</code></pre>
<p>（2）获取浮点型 0.0～1.0随机数</p>
<pre><code class="language-c++">rand.Seed(time.Now().UnixNano())
rand.Float64()
</code></pre>
<p>（3）获取 m～n随机数</p>
<pre><code class="language-c++">rand.Seed(time.Now().UnixNano())
随机数 = rand.Intn(n - m + 1) + m
</code></pre>
<p>比如 获取 [5,11]随机数，语法如下：</p>
<pre><code class="language-c++">rand.Intn(7) + 5
</code></pre>
<h3 id="6regexp">6、regexp正则表达式包</h3>
<h4 id="regexp">regexp包中核心函数及方法介绍</h4>
<pre><code class="language-c++">package main

import (
    &quot;fmt&quot;
    &quot;regexp&quot;
)

func main() {

    // 1、检查正则表达式与字节数组是否匹配
    flag, _ := regexp.Match(&quot;^\\d{6,15}$&quot;,[]byte(&quot;1234556788&quot;))
    fmt.Println(flag)//true

    // 2、检查正则表达式与字符串是否匹配。
    flag, _ = regexp.MatchString(&quot;^\\d{1,12}$&quot;,&quot;123222333&quot;)
    fmt.Println(flag)//true

    // 3、将正则表达式字符串编译成正则表达式对象（Regexp）
    MyRegexp, _ := regexp.Compile(&quot;^\\d{2,22}$&quot;)
    flag = MyRegexp.MatchString(&quot;123123a&quot;)
    fmt.Println(flag)//false

    // 4、ReplaceAll()将src中符合正则表达式的部分全部替换成指定内容。
    text := &quot;啊哈哈 123 嘿嘿嘿 333 火影 123222&quot;
    MyRegexp2, _ := regexp.Compile(&quot;[\\d\\s]+&quot;)
    ret := MyRegexp2.ReplaceAll([]byte(text),[]byte(&quot;x&quot;))
    fmt.Println(string(ret))//啊哈哈x嘿嘿嘿x火影x

    // 5、将字符串按照正则表达式分割成子字符串组成的切片。如果切片长度超过指定参数n，则不再分割。
    text = &quot;第一#第二##第三###第四####第五#####第六######第七####第八##第九&quot;
    MyREgexp3, _ := regexp.Compile(&quot;#+&quot;)
    arr := MyREgexp3.Split(text,5)
    fmt.Println(arr)//[第一 第二 第三 第四 第五#####第六######第七####第八##第九]
}
</code></pre>
<h3 id="7-goio">7 Go语言文件I/O操作</h3>
<h3 id="71">7.1 文件概述</h3>
<p>所谓“文件”，是指一组相关数据的有序集合。文件通常是驻留在外部介质（如磁盘等）上的，在使用时才调入内存。计算机系统是以文件为单位来对数据进行管理的。</p>
<p>一个文件要有由文件路径、文件名主干和文件名后缀（Windows有时会隐藏）组成的唯一标识，以便用户识别和引用，它常被称为文件名，但注意，此时所称的文件名包括3部分内容，而不是文件名主干。文件名主干遵守标识符的命名规则。文件名后缀用来表示文件的形式，一般不超过3个字母。如exe（可执行文件）、go（Go语言程序文件）、txt（文本文件）等。</p>
<h3 id="72-fileinfo">7.2 FIleInfo接口</h3>
<p>文件的信息包括文件名、文件大小、修改权限、修改时间等。</p>
<p>Go语言系统文件信息接口属性定义如下所示。</p>
<p><img alt="image-20201130162938417" src="../../imgs/image-20201130162938417.png" /></p>
<p>fileStat结构体（文件信息）定义如下所示。</p>
<p><img alt="image-20201130163004749" src="../../imgs/image-20201130163004749.png" /></p>
<p>fileStat结构体的常用方法如下所示。</p>
<p><img alt="image-20201130163038182" src="../../imgs/image-20201130163038182.png" /></p>
<p><strong>想要查看文件的信息，必须要知道文件的路径。</strong></p>
<p>下面通过一个案例演示获取文件信息：</p>
<pre><code class="language-c++">package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    // 绝对路径
    path := &quot;/Users/Wanghongwei/Desktop/ppyt.py&quot;
    printMessage(path)
    /*
        数据类型是:*os.fileStat
        文件名: ppyt.py
        是否为目录: false
        文件大小: 21
        文件权限: -rw-r--r--
        文件最后修改时间: 2020-11-10 14:32:31.806397859 +0800 CST
    */
}

func printMessage(filePath string) {
    fileInfo, err := os.Stat(filePath)
    if err != nil {
        fmt.Println(&quot;err:&quot;, err.Error())
    } else {
        fmt.Printf(&quot;数据类型是:%T \n&quot;, fileInfo)
        fmt.Println(&quot;文件名:&quot;, fileInfo.Name())
        fmt.Println(&quot;是否为目录:&quot;, fileInfo.IsDir())
        fmt.Println(&quot;文件大小:&quot;, fileInfo.Size())
        fmt.Println(&quot;文件权限:&quot;, fileInfo.Mode())
        fmt.Println(&quot;文件最后修改时间:&quot;, fileInfo.ModTime())
    }
}
</code></pre>
<h4 id="_8">文件权限简单说明</h4>
<p>文件的权限打印出来一共10个字符。文件有3种基本权限：r（read，读权限）、w（write，写权限）、x（execute，执行权限）。文件权限说明如图所示。</p>
<p><img alt="image-20201130163841937" src="../../imgs/image-20201130163841937.png" /></p>
<p><strong>文件权限简单说明：</strong></p>
<p><img alt="image-20201130163919410" src="../../imgs/image-20201130163919410.png" /></p>
<p><strong>文件权限八进制表示法</strong></p>
<p><img alt="image-20201130164000438" src="../../imgs/image-20201130164000438.png" /></p>
<p>例如：-rwxrwxrwx权限用八进制表示为：0777</p>
<h3 id="73">7.3 文件路径</h3>
<p>与文件路径相关的方法如表：</p>
<p><img alt="image-20201130164248411" src="../../imgs/image-20201130164248411.png" /></p>
<pre><code class="language-c++">package main

import (
    &quot;fmt&quot;
    &quot;path&quot;
    &quot;path/filepath&quot;
)

func main() {
    // 绝对路径
    filePath1 := &quot;/Users/Wanghongwei/DeskTop/ppyt.py&quot;
    // 相对路径
    filePath2 := &quot;../t2/variable.go&quot;
    // 是否为绝对路径
    fmt.Println(filepath.IsAbs(filePath1)) // true
    fmt.Println(filepath.IsAbs(filePath2)) // false
    // 获取相对路径
    fmt.Println(filepath.Rel(&quot;/Users/Wanghongwei&quot;,filePath1)) //DeskTop/ppyt.py &lt;nil&gt;
    // 获取绝对路径
    fmt.Println(filepath.Abs(filePath1)) ///Users/Wanghongwei/DeskTop/ppyt.py &lt;nil&gt;
    fmt.Println(filepath.Abs(filePath2)) ///Users/wanghongwei/GoProject/t2/variable.go &lt;nil&gt;
    // 拼接路径
    fmt.Println(path.Join(filePath1,&quot;..&quot;)) ///Users/Wanghongwei/DeskTop
    fmt.Println(path.Join(filePath1,&quot;../..&quot;)) ///Users/Wanghongwei
    fmt.Println(&quot;/Users/Wanghongwei/Desktop&quot;,filePath2) ///Users/Wanghongwei/Desktop ../t2/variable.go
}
</code></pre>
<h3 id="74">7.4 文件常规操作</h3>
<h4 id="_9">创建目录</h4>
<p><strong>创建目录时，如果目录存在，则创建失败。Go语言提供了两种方法。</strong></p>
<p><strong>1. os.Mkdir()</strong></p>
<p>os.MKdir()仅创建一层目录。官方文档解释如下所示。</p>
<pre><code class="language-c++">// Mkdir creates a new directory with the specified name and permission
// bits (before umask).
// If there is an error, it will be of type *PathError.
</code></pre>
<p><strong>2. os.MKdirAll()</strong></p>
<p>os.MKdirAll()创建多层目录。</p>
<pre><code class="language-c++">package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    // 创建单个目录
    filePath1 := &quot;./test1&quot;
    err := os.Mkdir(filePath1,os.ModePerm)
    if err != nil{
        fmt.Println(&quot;err&gt;&gt; &quot;,err)
    }

    // 创建多级目录
    filePath2 := &quot;./test2/adb/xyz&quot;
    err = os.MkdirAll(filePath2,os.ModePerm)
    if err != nil{
        fmt.Println(&quot;err&gt;&gt; &quot;,err)
    }
}
</code></pre>
<h4 id="_10">创建文件</h4>
<p>os.Create()创建文件，如果文件存在，会将其覆盖。官方文档解释如下所示。</p>
<pre><code class="language-c++">// Create creates or truncates the named file. If the file already exists,
// it is truncated. If the file does not exist, it is created with mode 0666
// (before umask). If successful, methods on the returned File can
// be used for I/O; the associated file descriptor has mode O_RDWR.
// If there is an error, it will be of type *PathError.
func Create(name string) (*File, error) {
    return OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666)
}
</code></pre>
<p><strong>该函数本质上是在调用os.OpenFile()函数。</strong></p>
<pre><code class="language-c++">package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    filePath := &quot;./test1/abc.json&quot;
    file, err := os.Create(filePath)
    if err != nil{
        fmt.Println(&quot;err&gt;&gt;&gt; &quot;,err)
    }else{
        fmt.Println(&quot;file&gt;&gt;&gt; &quot;, file)
    }
}
</code></pre>
<h4 id="_11">打开和关闭文件</h4>
<p>打开文件：让当前的程序和指定的文件建立一个链接。</p>
<p>os.Open()函数本质上是在调用os.OpenFile()函数。</p>
<pre><code class="language-c++">// Open opens the named file for reading. If successful, methods on
// the returned file can be used for reading; the associated file
// descriptor has mode O_RDONLY.
// If there is an error, it will be of type *PathError.
func Open(name string) (*File, error) {
    return OpenFile(name, O_RDONLY, 0)
}
</code></pre>
<pre><code class="language-c++">// OpenFile is the generalized open call; most users will use Open
// or Create instead. It opens the named file with specified flag
// (O_RDONLY etc.). If the file does not exist, and the O_CREATE flag
// is passed, it is created with mode perm (before umask). If successful,
// methods on the returned File can be used for I/O.
// If there is an error, it will be of type *PathError.
func OpenFile(name string, flag int, perm FileMode) (*File, error) {
    testlog.Open(name)
    f, err := openFileNolog(name, flag, perm)
    if err != nil {
        return nil, err
    }
    f.appendMode = flag&amp;O_APPEND != 0

    return f, nil
}
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-c++">package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    filePath := &quot;./test1/abc.json&quot;
    // 打开文件
    file, err := os.Open(filePath)
    if err != nil{
        fmt.Println(&quot;err&gt;&gt;&gt; &quot;,err)
    }else{
        fmt.Println(&quot;file&gt;&gt;&gt; &quot;,file)
    }

    // 以读写的方式打开，如果文件不存在就创建 
  // ———— 注意 目录必须存在！！！
    filePath2 := &quot;./test2/aaa.json&quot;
    file2, err2 := os.OpenFile(filePath2,os.O_CREATE,os.ModePerm)
    if err2 != nil{
        fmt.Println(&quot;err&gt;&gt;&gt; &quot;,err2)
    }else{
        fmt.Println(&quot;file2&gt;&gt;&gt; &quot;,file2)
    }
}
// 关闭文件
file.close()
file2.close()
</code></pre>
<h4 id="_12">删除文件</h4>
<p>删除文件有两种方法，如下所示：</p>
<p><img alt="image-20201130172314163" src="../../imgs/image-20201130172314163.png" /></p>
<pre><code class="language-c++">package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    // 1 删除单个文件或目录
    filePath := &quot;./test1/abc.json&quot;
    err := os.Remove(filePath)
    if err != nil{
        fmt.Println(err)
    }

    // 2 将目录中所有文件及目录删除 包括这个根目录！
    filePath2 := &quot;./test2&quot;
    err2 := os.RemoveAll(filePath2)
    if err2 != nil{
        fmt.Println(err2)
    }

    // 3 使用 os.Remove 方法删除非空的目录会报错！！！
    filePath3 := &quot;./test3&quot; // test3中有东西
    err3 := os.Remove(filePath3)
    if err3 != nil{
        fmt.Println(&quot;err3&gt;&gt;&gt; &quot;,err3) // remove ./test3: directory not empty
    }else{
        fmt.Println(filePath3)
    }
}
</code></pre>
<h4 id="_13">读取文件</h4>
<p><strong>读取文件数据</strong></p>
<pre><code class="language-c++">package main

import (
    &quot;fmt&quot;
    &quot;io&quot;
    &quot;os&quot;
)

func main() {
    // 读取文件数据
    filePath := &quot;./test1/abc.txt&quot;
    file, err := os.Open(filePath)
    if err != nil{
        fmt.Println(&quot;err&gt;&gt;&gt; &quot;,err)
    }else{
    // 读取文件
        bs := make([]byte,1024*8,1024*8)
        n := -1
        for {
            n, err = file.Read(bs)
            if n == 0 || err == io.EOF{
                fmt.Println(&quot;读取文件结束！&quot;)
                break
            }
            fmt.Println(string(bs[:n]))
        }
    }
    // 关闭文件
    file.Close()
}
/*
whw
123
666
王宏伟666
读取文件结束！
 */
</code></pre>
<h4 id="_14">写入文件</h4>
<pre><code class="language-c++">package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    // 读取文件数据
    filePath := &quot;./test1/writeTest.txt&quot;
    file, err := os.OpenFile(filePath,os.O_RDWR|os.O_CREATE,os.ModePerm)
    if err != nil{
        fmt.Println(&quot;err&gt;&gt;&gt; &quot;,err)
    }else{
        // 写入文件
        n, err := file.Write([]byte(&quot;abdcsa13\n&quot;))
        if err != nil{
            fmt.Println(&quot;写入文件异常:&quot;,err)
        }else{
            fmt.Println(&quot;n:&quot;,n) // 9
        }
        // 写入汉字！
        n, err = file.WriteString(&quot;王宏伟666&quot;)
        if err != nil{
            fmt.Println(&quot;写入汉字异常&gt;&gt;&quot;,err)
        }else{
            fmt.Println(&quot;n:&quot;,n) // 12
        }
    }
    // 关闭文件
    file.Close()
}
</code></pre>
<h4 id="_15">复制文件</h4>
<p>Go语言提供了copyFile()方法，用来复制文件。</p>
<pre><code class="language-c++">package main

import (
    &quot;fmt&quot;
    &quot;io&quot;
    &quot;os&quot;
)

func main() {
    // 源文件相对路径
    srcFilePath := &quot;./test1/writeTest.txt&quot;
    // 准备生成的目标文件路径 ！ 注意test2这个目录必须存在！！！
    newFilePath := &quot;./test2/copyTest.txt&quot;
    total, err := copyFile(newFilePath,srcFilePath)
    if err != nil{
        fmt.Println(&quot;err:&quot;,err)
    } else{
        fmt.Println(&quot;复制OK！&quot;,total)
    }
}

func copyFile(destFile, srcFile string)(int64, error){
    file1, err := os.Open(srcFile)
    if err != nil{
        return 0, err
    }
    file2, err := os.OpenFile(destFile,os.O_RDWR|os.O_CREATE,os.ModePerm)
    if err != nil{
        return 0, err
    }
    // defer close
    defer file1.Close()
    defer file2.Close()
    // 复制！
    return io.Copy(file2, file1)
}
</code></pre>
<h3 id="75-ioutil">7.5 ioutil包</h3>
<p>ioutil包的核心函数如表所示：</p>
<p><img alt="image-20201130175908962" src="../../imgs/image-20201130175908962.png" /></p>
<pre><code class="language-c++">package main

import (
    &quot;fmt&quot;
    &quot;io/ioutil&quot;
    &quot;os&quot;
)

func main() {
    // 打开文件
    filePath1 := &quot;./test1/writeTest.txt&quot;
    data, err := ioutil.ReadFile(filePath1)
    if err != nil{
        fmt.Println(&quot;err&gt;&gt; &quot;,err)
    }else{
        fmt.Println(&quot;data&gt;&gt; \n&quot;,string(data))
    }

    // 写入文件 会覆盖之前的内容！
    filePath2 := &quot;./test2/copyTest.txt&quot;
    writeString := &quot;金刚葫芦娃&quot;
    err = ioutil.WriteFile(filePath2,[]byte(writeString),os.ModePerm)
    if err != nil{
        fmt.Println(&quot;写入文件失败&quot;)
    }

    // 文件复制
    err = ioutil.WriteFile(filePath2,data,os.ModePerm)
    if err != nil{
        fmt.Println(&quot;文件复制异常！&quot;,err.Error())
    }

    // 遍历目录 v是指定目录里的文件或文件夹
    dirName := &quot;./&quot;
    fileInfos, err := ioutil.ReadDir(dirName)
    if err != nil{
        fmt.Println(&quot;目录遍历异常！&quot;,err.Error())
    }else{
        for i, v := range fileInfos{
            fmt.Println(i, v.Name(), v.IsDir(),v.Size(), v.ModTime())
        }
    }

    // 创建目录
    fileName, err := ioutil.TempDir(&quot;./&quot;,&quot;temp&quot;)
    if err != nil{
        fmt.Println(&quot;创建目录失败！&quot;,err.Error())
    }else{
        // 注意后面还有数字！temp736138268
        fmt.Println(&quot;fileName&gt;&gt;&gt; &quot;,fileName)
    }

    // 创建文件
    file1, err1 := ioutil.TempFile(fileName,&quot;test.txt&quot;)
    if err1 != nil{
        fmt.Println(&quot;err1&gt;&gt;&gt; &quot;,err1)
    }else{
        // 注意文件名后面也有随机数字！
        file1.WriteString(&quot;写入内容：&quot; + file1.Name())
    }
    file1.Close()
}
</code></pre>
<h3 id="76-bufio">7.6 bufio包</h3>
<p><strong>bufio实现了带缓冲的I/O操作，达到高效读写。</strong></p>
<p><strong>缓冲区的原理</strong></p>
<p>bufio包对io包下的对象Reader、Writer进行包装，分别实现了io.Reader和io.Writer接口，提供了数据缓冲功能，能够一定程度减少大块数据读写带来的开销，所以bufio比直接读写更快。</p>
<p>把文件读取进缓冲区之后，再读取的时候就可以避免文件系统的输出，从而提高速度；在进行写操作时，先把文件写入缓冲区，然后由缓冲区写入文件系统。</p>
<p>有人可能会困惑：直接把“内容—文件”和“内容—缓冲区—文件”相比，缓冲区似乎没有起到作用。其实在生活中也有这样的例子，比如每当家里产生垃圾的时候，不会有人马上去楼下倒垃圾，因为这样反复地上下楼非常麻烦，通常家里都会准备个小垃圾桶，等垃圾桶装满了之后把一批垃圾一起倒掉。用计算机的思想来看，垃圾桶就充当了缓冲区的角色。</p>
<p>缓冲区的设计是为了存储多次的写入，最后一口气把缓冲区内容写入文件。当发起一次读写操作时，计算机会首先尝试从缓冲区获取数据；只有当缓冲区没有数据时，才会从数据源获取数据更新缓冲。</p>
<p><img alt="image-20201130194040936" src="../../imgs/image-20201130194040936.png" /></p>
<p><strong>Scanner</strong></p>
<p>实际使用中，更推荐使用Scanner对数据进行读取，而非直接使用Reader类。Scanner可以通过splitFunc将输入数据拆分为多个token，然后依次进行读取。和Reader类似，Scanner需要绑定到某个io.Reader上，通过NewScanner()进行创建。</p>
<p>默认方法如表：</p>
<p><img alt="image-20201130200348065" src="../../imgs/image-20201130200348065.png" /></p>
<p>bufio 模块提供了几个默认splitFunc，能够满足大部分场景的需求，如下表所示：</p>
<p><img alt="image-20201130200428793" src="../../imgs/image-20201130200428793.png" /></p>
<p>可以为Scanner指定splitFunc，方法如下所示：</p>
<pre><code class="language-c++">scanner.split(bufio.ScanWords)
</code></pre>
<pre><code class="language-c++">package main

import (
    &quot;bufio&quot;
    &quot;fmt&quot;
    &quot;strings&quot;
)

func main() {
    // 创建Reader对象并传入要分割的字符串
    reader1 := bufio.NewReader(strings.NewReader(&quot;abcsdsaf 123 dfs&quot;))
    // 创建Scanner对象
    scanner := bufio.NewScanner(reader1)
    // 指定分割方法，按照空格进行拆分
    scanner.Split(bufio.ScanWords)
    // 循环读取
    for scanner.Scan(){
        fmt.Println(scanner.Text())
        if scanner.Text() == &quot;q!&quot;{
            break
        }
    }
}
/*
abcsdsaf
123
dfs
 */
</code></pre>
<p><strong>bufio.Reader结构体</strong></p>
<ol>
<li>bufio.Reader</li>
</ol>
<p>bufio.Reader的常用方法如表:</p>
<p><img alt="image-20201130194347063" src="../../imgs/image-20201130194347063.png" /></p>
<ol>
<li>NewReader()与NewReaderSize()</li>
</ol>
<p>将rd封装成一个拥有size大小缓存的bufio.Reader对象，NewReader()相当于NewReaderSize(rd, 4096)。</p>
<ol>
<li>Read()</li>
</ol>
<p>bufio.Read(p []byte) 相当于读取大小为len(p)的内容，使用思路如下。（1）当缓冲区有内容时，将缓冲区内容全部填入p并清空缓冲区。（2）当缓冲区没有内容且len(p)＞len(buf)，即要读取的内容比缓冲区还要大，直接去文件读取即可。（3）当缓冲区没有内容且len(p)＜len(buf)，即要读取的内容比缓冲区小，缓冲区从文件读取内容充满缓冲区，并将p填满（此时缓冲区有剩余内容）。（4）以后再次读取时缓冲区有内容，将缓冲区内容全部填入p并清空缓冲区，同情况（1）。</p>
<ol>
<li>ReadLine()</li>
</ol>
<p>ReadLine()是一个低级的、原始的行读取操作，大多数情况下，应该使用ReadBytes('\n')或ReadString('\n')，或者使用一个Scanner。ReadLine()通过调用ReadSlice()方法实现，返回的也是缓存的切片。ReadLine()尝试返回一个单行数据，不包括行尾标记（\n或\r\n），如果在缓存中找不到行尾标记，则设置isPrefix为true，表示查找未完成，同时读出缓存中的数据并作为切片返回；只有在当前缓存中找到行尾标记，才将isPrefix设置为false，表示查找完成。可以多次调用ReadLine()来读出一行，返回的数据在下一次读取操作之前是有效的。如果ReadLine()无法获取任何数据，则返回一个错误信息（通常是io.EOF）。</p>
<ol>
<li>ReadBytes() ***</li>
</ol>
<p>ReadBytes()在b中查找delim并读出delim及其之前的所有数据。如果ReadBytes()在找到delim之前遇到错误，则返回遇到错误之前的所有数据，同时返回遇到的错误（通常是io.EOF）。只有当ReadBytes()找不到delim时，err才不为nil。</p>
<p>对于简单的任务，使用Scanner可能更方便。</p>
<ol>
<li>ReadString() ***</li>
</ol>
<p>ReadString()功能同ReadBytes()，只不过返回的是一个字符串。</p>
<pre><code class="language-c++">package main

import (
    &quot;bufio&quot;
    &quot;fmt&quot;
    &quot;io&quot;
    &quot;os&quot;
)

func main() {
    testReader()
}

func testReader(){
    fileName1 := &quot;./test1/abc.txt&quot;
    // 打开文件
    file1, _ := os.Open(fileName1)
    // 创建缓冲区
    reader1 := bufio.NewReader(file1)
    fmt.Printf(&quot;%T \n&quot;, reader1) // *bufio.Reader
    // 从缓冲区冲读取
    for {
        // 以/n问分隔符读取
        s1, err := reader1.ReadString('\n')
        fmt.Println(s1)
        if err == io.EOF{
            fmt.Println(&quot;读取完毕&quot;)
            break
        }
    }
    file1.Close()
}
</code></pre>
<p><strong>bufio.Writer结构体</strong></p>
<ol>
<li>buffo.Writer</li>
</ol>
<p>bufio.Writer的常用方法如表:</p>
<p><img alt="image-20201130195234137" src="../../imgs/image-20201130195234137.png" /></p>
<ol>
<li>Write()</li>
</ol>
<p>bufio.Write(p []byte)的使用思路如下:</p>
<p>（1）判断缓冲区中可用容量是否可以放下 p。</p>
<p>（2）如果能放下，直接把p放到缓冲区。</p>
<p>（3）如果缓冲区的可用容量不足以放下p，且此时缓冲区是空的，直接把p写入文件即可。</p>
<p>（4）如果缓冲区的可用容量不足以放下p，且此时缓冲区有内容，则用p把缓冲区填满，把缓冲区所有内容写入文件，并清空缓冲区。</p>
<p>（5）判断p的剩余内容大小能否放到缓冲区，如果能放下则把内容放到缓冲区，同情况（2）。</p>
<p>（6）如果p的剩余内容依旧大于缓冲区（注意此时缓冲区是空的），则把p的剩余内容直接写入文件，同情况（3）。</p>
<pre><code class="language-c++">package main

import (
    &quot;bufio&quot;
    &quot;fmt&quot;
    &quot;io&quot;
    &quot;os&quot;
)

func main() {
    testWriter()
}

func testWriter(){
    fileName := &quot;./test1/abc.txt&quot;
    // 打开文件
    file, _ := os.Open(fileName)
    // 创建读缓冲区
    reader := bufio.NewReader(file)
    fileName2 := &quot;./test1/writeText.txt&quot;
    // 打开文件
    file2, _ := os.OpenFile(fileName2,os.O_WRONLY|os.O_CREATE,os.ModePerm)
    // 创建读写缓冲区
    writer1 := bufio.NewWriter(file2)
    for{
        // 将读取到的数据写入另一个文件
        bs, err := reader.ReadBytes(' ')
        writer1.Write(bs)
        writer1.Flush()
        if err == io.EOF{
            fmt.Println(&quot;文件读取完毕&quot;)
            break
        }
    }
    file.Close()
    file2.Close()
}
</code></pre>
<h2 id="_16"></h2>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../7/" class="btn btn-neutral float-right" title="07 网编并发">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../5/" class="btn btn-neutral" title="05 结构体接口与反射"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../5/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../7/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
